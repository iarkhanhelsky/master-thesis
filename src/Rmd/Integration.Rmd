---
title: "Применение вейвлет преобразования в численном интегрировании функций"
author: "Архангельский Илья Андреевич"
date: "May 6, 2015"
output:
  pdf_document:
    fig_caption: yes
    highlight: pygments
    keep_tex: yes
    number_sections: yes
    pandoc_args: [
        '--listings',
        '--variable', 'documentclass:article',
        '--variable', 'classoption:a4papper,11pt',
        '--variable', 'geometry:margin=0in'
        ]
    toc: yes
    includes:
      in_header: ../style/header_simple.tex
---
```{r echo=FALSE}
  # Imports
  library('reshape2')
  library('ggplot2')
  library('memoise')

```
# Введение 
Определим базовый вейвлет хаара: 
```{r}
wavelet.haar <- function(t, j = 0, k = 0) {
  # Материнский вейвлет. Функция заданная на отрезке [0, 1]
  haar.mother <- function(t) {
    if(0 <= t && t < 1/2) {
      return(1)
    } else if (1/2 <= t && t <= 1) {
      return(-1)
    } else {
      return(0)
    }
  } 
  
  # Функция порождающая семейства вейвлетов
  haar.jk <- function(t, j, k) {
    return(2^(-j/2) * haar.mother(2^-j * t - k))
  }
  
  # Векторный вариант
  return(Vectorize(haar.jk, vectorize.args=c('t'))(t, j, k))
}
```

```{r, echo=FALSE}
  t <- seq(-1, 1, length.out=1000)
  data <- data.frame(
    a = wavelet.haar(t, 0, 0),
    b = wavelet.haar(t, 1, 0),
    c = wavelet.haar(t, -1, 0),
    t = t
  )
  
  data.long <- melt(data, id='t')
  ggplot(data=data.long,
       aes(x=t, y=value, colour=variable)) +
       scale_colour_hue(labels=c("j = 0, k = 0", "j = 1, k = 1", "j = -1, k = 1")) +
       facet_wrap(~variable) +
       geom_line()

  # cleanup
  rm(t, data, data.long)
```

# Аппроксимация функции одной переменной с помощью вейвлета Хаара.

Определим вспомогательные функции
```{r}
  c.0 <- function(f) {
    integrate(f, lower = 0, upper = 1)$value
  }

  d.jk <- function(f, j, k) {
    lower <- 2**j*k
    upper <- 2**j*(k + 1)
    integrate(function(t) f(t) * wavelet.haar(t, j, k), lower, upper)$value
  }

  approximate <- function(f, levels.max) {
    m.d.jk <- memoise(d.jk)
    return(function(t) {
      s <- c.0(f)
      for(j in c(0:levels.max)) {
        for(k in c(0:(2**levels.max))) {
          s <- s + m.d.jk(f, -j, k) * wavelet.haar(t, -j, k)
        }
      }
      s
    })
  }
```


```{r}
  t <- seq(0, 1, 0.01)
  f <- function(t) sin(t * 5 * pi)
  u <- approximate(f, levels=10)
  
  qplot(t, u(t))
```